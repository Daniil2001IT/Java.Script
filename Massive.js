
//const fib = [1, 1, 3, 4, 5, 6, true, false, 'Привет!', {}, ] // Числа Фибоначи - это числа, которые являются Суммой 2 Предыдущих, как в Квадратных скобках! Вторую 1 ставлю, потому что складываю: 1 + пустота, тоесть 0 = 1 + 1 = 2 + 1 и так далее. Числа - Это Примитивные Данные, их я могу хранить в Массиве. Могу хранить Строки: ['', '', '']. Могу хранить Булион значения, обЪекты и так далее.


// Прототипы - это по сути набор взаимосвязанных обЪектов с помощью, которых я для тех или иных Структур Данных добавляю определённый Функционал
// Корневой протип в jave.script - это Obdject! Он так же есть в Prototype - только в самом Низу! У него нет свойства Proto, так как это Базавый класс 

const cars = ['Мазда', 'Форд', 'БМВ', 'Мэрсэдэс'] // В Консоли в самомо низу написано Prototype. У него класс Array. Через Prototype я могу посмотреть все доступные Методы для использования Данного Массива

//console.log(cars) // Массивы, Функции, ОбЪекты - это и есть ОбЪект. Всё что в jave.scripte - это ОбЪект! 


// Function

//function addItemToEnd () {
//}

// Метод

//cars.push('Порш') // Через точку я обращаюсь к Массиву - как в объекте. При помощи метода push  я добавляю новые слова в Массив - в самый конец! Если функцию push. я вызываю через оъект - cars и через точку, то это считается методом. Если push вызываю через - function addItemToEnd () {} то push я буду использовать уже, как Функцию 

//console.log(cars)

//cars.unshift('Волга')  // Через метод unshift я добавляю новые слова уже Только в Начало Массива! 

//console.log(cars)

//cars.shift()

//console.log(cars) // При помощи метода shift  я удаляю Первое слово в Массиве! Через метод - unshift я добавил Волгу, а через метод shift Волгу теперь Удалил 


//const firstItem = cars.shift() // Через такой способ, тоесть через переменную и через метод shift я удаляю первое слвово в Массиве и вывожу его отдельно, чтобы дальше с ним работать 
//console.log(firstItem)
//console.log(cars)

//const lastCar = cars.pop() // Аналогично методу shift - только удаляю слово уже в Самом Конце! 
//console.log(lastCar)
//console.log(cars)

//console.log(cars.reverse()) // Это метод переваривает весь Массив! Тоесть слова в массиве идут уже с Конца через запятую, а не с Начала!
//console.log(cars)

// console.log(cars.includes('Мазда')) // При помощи метода includes я спрашиваю у Массива - есть такой Параметр в виде слова Мазад или нет!


// Задача 1

// const text = 'Привет, мы изучаем Java.script'
// const reverseText = text.split(' , ').reverse().join('') 

// Метод split берёт и делит Строчку, возвращая Массив! В скобках указываю любой знак припенания к примеру - split(',') и в console.log этот знак припенания разделяет уже мою Строчку! Если в скобках ничего не укажу, то выведится массив именно из букв - каждая буква будет под своим номером!

// При помощи метода reverse() - мои буквы идут уже в Обратном Порядке! 

// При помощи метода join() - я соединяю уже Массив - тоесть буквы в одну строку, но буквы будут чередоваться через Запятую по Умолчанию, так как в join() - именно в скобках ничего не указал! Если укажу в скобках -  (''), то буквы соединяться и будут уже идти Слитно и в обратной Последовательности из - за Метода - reverse()!
// console.log(reverseText)


// В Массиве я могу использовать метод - index.Of



// 1 Вариант Решения 

//console.log(cars.indexOf('БМВ')) // // При помощи метода - indexOf я вывожу нужную мне цифру через слово БМВ в Массиве

// 2 Вариант Решения 

//const index = cars.indexOf('БМВ') // Если будет другое слово, которого нет в Массиве, то Результат - 1! По факту Ошибка. indexOf хорошо работает с Примитивными Типами Данных - такие как: строчки, числа и так далее 
//console.log(cars[index]) // Вывел просто слово БМВ через переменную.
//cars[index] = 'Порш'
//console.log(cars) // Заменил слово БМВ на Порш! 



// 3 Вариант Решения

//const people = [
//{name: 'Shlyapkin Daniil', budget: 50000}, // Новый для меня Синтаксис в Объектах 
// {name: 'Shlyapkin Dmitriy', budget: 80000},
//{name: 'Shlyapkin Alexey', budget: 70000},
 // ]


// 3.) Решение через Цикл этой же Задачи!

    // let findedPerson // Создал переменную, чтобы через неё уже найти Человека у которого Бюджет - 80000!
    // for (const person of people) { // создаю переменную - const person, чтобы работать с Циклом Масссива. Через of смотрю в Массиве people 
    // console.log(person) // Получаю тот же самый Результат, что и в Объекте Выше
    // if (person.budget === 80000) { 
      //  findedPerson =  person
    // }
 //  }

  // console.log(findedPerson)


// 3.)


//const person = people.find(function (person) { 
   
//return  person.budget === 50000 // Через return я даю условие - person.budget === 80000. И через console.log() это условие уже нахожу! 
// }) 
//console.log(persone)

    // Тут я использовал find - сокращённая версия findIndex. 

   // Использую find, использую person в Переменной и в выдуманной Мной Функции для того, чтобы не писать в console.log(people[person])!!!! По Факту Сокращённый Вариант!
  
   // Метод findIndex нужен для работы с Объектами! Эта функция Анонимная. Её можно использовать, чтобы быстро и без запары найти и выести нужное мне значение в Объекте например . Метод findIndex Является Циклом!

 

// 3.) Так же вывел нужное мне значение из Объекта - только сделал через Стрелочную Функцию 

   //const person = people.find((person) => {  // Развёрнутый вариант! 
   //return person.budget === 50000
   //} )
   

   // Описываю кубэк функцию. Обозначаю, как Стрелочную Функцию
  //console.log(person)

   

   //const person = people.find(person =>   person.budget === 50000)  // Сокращённый Вариант той же самой Стрелочной Функции! 
  // После find Две скобки убрал, потому что один Параметр - return убрал, потому что вся Функция теперь написана в одну строчку! Именно Этот код называется - Лям Дэ Функция - не создаю лишних переменн!  
  //console.log(person)
   


// 4.) Проверка наличие Параметра через Метод inckludes


 //const cars2 = ['Мазда', 'Форд', 'БМВ', 'Мэрсэдэс']


 //cars2.includes('Мазда') // При помощи метода includes я спрашиваю у Массива - есть такой Параметр в виде слова Мазад или нет! Через console.log проверил  наличие слова - Мазад. Слово появилось - значит есть 


 //console.log('Мазда')


 //console.log(cars2.includes('Форд')) // Всё так же проверяю через includes. Просто сокращённная версия! Тут ответ будет писаться в Браузере, как True, а не словом Форд! Если укажу Парамерт, которого нет в Массиве, то ответ будет - False!



// 5.) 

 // При помощи Метода map  я получаю возможность видоизменять Массив, делая Параметры с Заглавных Букв! При помощи  Метода toUpperCase() - и делаю слова с Заглавных Букв. Без мнтода map - этого не получилось бы! Метод map всегда возврощает Новый Мвссив! 


 //const appeCaseApe = cars.map(cars => { 

 //return cars.toUpperCase()
 //} )

 //console.log(appeCaseApe) 
// console.log(cars) // Параметры в Массиве останутся без изменений тогда, потому что Метод map всегда возврощает Новый Мвссив! 



// 6.)


//const pow2 = num => num ** 2

//const fibFib = fib.map ( pow2) // Функцию здесь я не вызываю, а просто её передаю. Аналогичный результат! Просто вариант более Сокращённный! 

//console.log(fibFib)



//fib = [1, 1, 3, 4, 5, 6]

//const pow2 = num => num ** 2 // Функция принимающая  себя число и возводящее его в кавадрат
//const sqrt = num => Math.sqrt(num) // создал отдельную функцию. Кароче говоря при помощи  Math.sqrt(num) я вывожу корень из каждого числа - После возведение чисел во 2 степень!  2 действия получается. Прикольно. Хех!

//const pow2Fib = fib.map(pow2).map(Math.sqrt)  // fib.map(pow2).map - это уже будет Массив. Могу дополнительно использовать find или map например. 

//console.log(pow2Fib)



//const fib = [1, 1, 3, 4, 5, 6,]

//const pow2Fib2 = fib.map ( num => num ** 2)

//console.log(pow2Fib) // В итоге в Консоли числа умножаются теперь сами на себя. Именно при помощи - num ** 2!



// 6.) // Благодаря такому синтаксису в java.script можно создавать такие красивые и сложные цэпочки в Коде 

//fib = [1, 1, 3, 4, 5, 6]


//const lasLas = fib => fib ** 2
//const nameName = fib => Math.sqrt(lasLas)

//const runRun = fib.map(lasLas).map(Math.sqrt)
 
//console.log(runRun)



// 7.) Фильтрация Массива! 


 //const fib = [1, 1, 3, 4, 5, 6]



 //const lasLas = fib => fib ** 2

//const nameName = fib => Math.sqrt(lasLas) // в этой задачи эту строку не использую 

//const runRun = fib.map(lasLas).map(Math.sqrt)  // в этой задачи эту строку не использую 
 

 //const pow2Fib = fib.map(lasLas)
 //const fileteredNumbers = pow2Fib.filter(fib => fib > 20) // Встроенный Метод. При помощи него я могу крайне просто работать с Данными. // Возвращаю fib, если он больше 20. 
 //console.log(pow2Fib)
 //console.log(fileteredNumbers)



// 8.) Объединение Массива при помощи метода reduse!
// Задача - проссуммировать бюджет всех людей у, котроых он выше 2000 тысяч! Суммировать буду Себя и Диму, так как у Лёхи меньше 2000!


const people = [
{name: 'Shlyapkin Daniil', budget: 50000}, // Новый для меня Синтаксис в Объектах 
 {name: 'Shlyapkin Dmitriy', budget: 80000},
{name: 'Shlyapkin Alexey', budget: 10000},
 ]

// people.reduce(function(acc, person) {}, 0 ) // Принимает 1 Параметром - Функцию, а 2 Параметром принимает в себя некое начальное значение с которого я хочу считать - допусти с 0!  
 //  Функция в свою очередь принимает никий аккумулятор - acc - то значение, которое будет переобновляться на каждые аттерации данного Массива и оно будет Сохранено! 
//  person - тот Элемент по, которому я делаю Аттерацию! 


//const allBudget = people.reduce((acc, person) => { // тоже самое - только Сокащённый Вариант!
 // if(person.budget > 2000) {
//acc += person.budget
//}
// acc += person.budget // return не пишу. Я видоизменяю Аккумулятор. Складываю Аккумулятор с person.budget
// return acc // Вернул Аккумулятор 
//}, 0 )
// Метод reduce возвращает Финальное значение, когда пройдёт Аттерация!
//console.log(allBudget)




// Тут я уже вместо Метода reduse Применяю filter!

const theLasLas = people // Это всё Чэйнинг. Чэйнинг - это, когда я вызыаю Подряд некоторые Методы! Тип визуально выглядит Акуратно, а так одно и тоже. Хех 
.filter(person => person.budget > 20000)
.reduce((acc, person) => {
 acc += person.budget
 return acc
 }, 0) 
 console.log(theLasLas)




// 9.) Левый Пример - для себя иметь Ввиду 
// Например


const displayAytams = allItems.filter(item => item.name.containse('phone') !== -1) 
// !== -1) - Типо  indexOf не равняется Единицы!
 // containse - Метод в строке, который спрашивает - а содержится ли такая подстрока в Строке. indexOf тоже самое по Принципу. 
// indexOf !== -1 - 












  



















































